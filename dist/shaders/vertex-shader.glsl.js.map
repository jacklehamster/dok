{"version":3,"sources":["../../shaders/vertex-shader.glsl.js"],"names":["define"],"mappings":";;AAAAA,OAAO,YAAW;AACd;AAuCH,CAxCD","file":"vertex-shader.glsl.js","sourcesContent":["define(function() {\n    return `\n    \nvarying vec2 vUv;\nattribute float tex;\nattribute float light;\nattribute float wave;\nattribute vec3 spot;\nattribute vec4 quaternion;\nvarying float vTex;\nvarying float vLight;\nuniform vec3 vCam;\nuniform float curvature;\nuniform float time;\nuniform float bigwave;\n\nvoid main()  {\n    vTex = tex;\n    vUv = uv;\n\n    vec3 newPosition = rotateVectorByQuaternion( position - spot, quaternion ) + spot;\n    vLight = 1.0/ sqrt(500.0 / distance(newPosition, vCam)) * light;\n\n    float dist = distance(newPosition, vCam);\n    if (curvature > 0.0) {\n        newPosition.z = newPosition.z - curvature * (dist*dist)/20000.0;\n    }\n    if (wave > 0.0) {\n        newPosition.z = newPosition.z + wave * (sin(newPosition.x*15.0 + time/2.0) - cos(newPosition.y*7.0 + time/2.0));\n        if (bigwave > 0.0) {\n            newPosition.z = newPosition.z + wave * bigwave\n            * (sin(newPosition.x/500.0 + time/10.0) - sin(newPosition.y/700.0 + time/10.0));\n        }\n    }\n\n    vec4 mvPosition = modelViewMatrix * vec4(newPosition, 1.0 );\n    gl_Position = projectionMatrix * mvPosition;\n}    \n\n    `;\n});\n"]}