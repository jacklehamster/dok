{"version":3,"sources":["../turbosort.js"],"names":["define","SIZE","buckets","Uint32Array","counts","indexFunction","identity","getMinMax","array","offset","length","firstIndex","minNum","maxNum","previousNum","inOrder","i","index","min_max_result","min","max","a","turboSort","size","func","Math","turboSortHelper","compareIndex","b","arrayInfo","range","bucketSize","floor","voyager","bucketId","newSpot","swap","temp"],"mappings":"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","file":"turbosort.js","sourcesContent":["define(function() {\n\n    const SIZE = 1000000;\n    const buckets = new Uint32Array(SIZE+1);\n    const counts = new Uint32Array(SIZE+1);\n    let indexFunction = identity;\n\n    /**\n     *  FUNCTION DEFINITIONS\n     */\n    function getMinMax(array, offset, length) {\n        let firstIndex = indexFunction(array[offset]);\n        let minNum = firstIndex;\n        let maxNum = firstIndex;\n        let previousNum = firstIndex;\n        let inOrder = true;\n        for(let i=1; i<length; i++) {\n            const index = indexFunction(array[offset+i]);\n            if(previousNum > index) {\n                inOrder = false;\n                if(index < minNum) {\n                    minNum = index;\n                }\n            } else {\n                if(index > maxNum) {\n                    maxNum = index;\n                }\n            }\n            previousNum = index;\n        }\n        min_max_result.min = minNum;\n        min_max_result.max = maxNum;\n        min_max_result.inOrder = inOrder;\n        return min_max_result;\n    }\n    const min_max_result = {\n        min: 0,\n        max: 0,\n        inOrder: false,\n    };\n\n    function identity(a) {\n        return a;\n    }\n\n    function turboSort(array, size, func) {\n        if(array) {\n            size = size ? Math.min(size,array.length) : array.length;\n            if(size > 1) {\n                indexFunction = func ? func : identity;\n                turboSortHelper(array, 0, size ? size : array.length);\n            }\n        }\n    }\n\n    function compareIndex(a,b) {\n        return indexFunction(a)-indexFunction(b);\n    }\n\n    function turboSortHelper(array, offset, length) {\n        const arrayInfo = getMinMax(array, offset, length);\n        if(arrayInfo.inOrder) {\n            return;\n        }\n        const min = arrayInfo.min;\n        const max = arrayInfo.max;\n        const range = max-min;\n        if(range===0) {\n            return;\n        }\n        \n        const bucketSize = Math.min(length, SIZE);\n\n        let i, index;\n        for(i=0; i<bucketSize; i++) {\n            counts[i] = 0;\n        }\n        counts[bucketSize] = 1;\n        for(i=0; i<length; i++) {\n            index = Math.floor((bucketSize-1) * (indexFunction(array[i+offset]) - min)/range);\n            counts[index]++;\n        }\n\n        for(i=0; i<bucketSize; i++) {\n            buckets[i] = 0;\n        }\n        buckets[bucketSize] = offset + length;\n        buckets[0] = offset;\n        for(i=1; i<bucketSize; i++) {\n            buckets[i] = buckets[i-1] + counts[i-1];\n        }\n\n        let voyager = offset, bucketId = 0;\n        while(bucketId<bucketSize) {\n            index = Math.floor((bucketSize-1) * (indexFunction(array[voyager]) - min)/range);\n            const newSpot = buckets[index] + --counts[index];\n            swap(array,voyager,newSpot);\n            while(!counts[bucketId]) {\n                bucketId++;\n            }\n            voyager = buckets[bucketId];\n        }\n        for(i=0; i<bucketSize; i++) {\n            counts[i] = buckets[i + 1] - buckets[i];\n        }\n        for(i=0; i<bucketSize; i++) {\n            if(counts[i] > 1) {\n                turboSortHelper(array, buckets[i], counts[i]);\n            }\n        }\n    }\n\n    function swap(array, a, b) {\n        const temp = array[a];\n        array[a] = array[b];\n        array[b] = temp;\n    }\n\n    return turboSort;\n});\n"]}